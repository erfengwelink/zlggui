//*------------------------------------------------------------------------------------------------
//* 文件名				: os_api.c
//* 功能描述			: 基于uC/OS基本函数库开发的能够最大限度满足上层系统需求的API。
//* 作者    			: 焦海波
//* 版本				: 0.1
//* 建立日期、时间		: 2006/06/10 10:45
//* 最近修改日期、时间	: 
//* 修改原因			: 
//*------------------------------------------------------------------------------------------------
//*------------------------------------------ 头文件 -----------------------------------------------
#include	"../includes.h"
//*================================================================================================
//*											函	数	区
//*================================================================================================
//*------------------------------------------------------------------------------------------------
//* 函数名称 : __MSToOSTicks
//* 功能描述 : 将毫秒转变成时钟节拍
//* 入口参数 : <uwMS>[in] 节拍数
//* 出口参数 : 毫秒数
//*------------------------------------------------------------------------------------------------
static INT16U __MSToOSTicks(INT16U uwMS)
{
	INT16U	__uwDelayTicks;
	
	if(uwMS != 0)
	{
		__uwDelayTicks = (uwMS * OS_TICKS_PER_SEC)/1000;
		if(__uwDelayTicks < 1)
			__uwDelayTicks = 1;
		else if(__uwDelayTicks > 65535)
			__uwDelayTicks = 65535;
		else;
	}
	else
		__uwDelayTicks = 0;		
		
	return __uwDelayTicks;
}
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPISemWait
//* 功能描述 : 在指定的时间内（单位为毫秒）等待指定的信号量可用
//* 入口参数 :     <hSem>[in] 等待的信号量句柄
//*			 : <uwWaitMS>[in] 指定最长等待时间单位为毫秒，实际等待时间为内核调度间隔时间的整数倍，0ms表示
//*			 :                该函数将无限期等待下去直至信号量可用
//* 出口参数 : - OS_NO_ERR         : 信号量可用
//*			 : - OS_TIMEOUT        : 时间溢出，信号量不可用
//*			 : - OS_ERR_EVENT_TYPE : hSem参数携带的事件类型并不是信号量而是其它类型
//*			 : - OS_ERR_PEND_ISR   : 不能在ISR中调用该函数
//*			 : - OS_ERR_PEVENT_NULL: hSem是一个空指针
//*------------------------------------------------------------------------------------------------
INT8U OSAPISemWait(HANDLER hSem, INT16U uwWaitMS)
{
	INT8U	__ubRtnVal;	
		
	OSSemPend(hSem, __MSToOSTicks(uwWaitMS), &__ubRtnVal);
	
	return __ubRtnVal;
}
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPISemFree
//* 功能描述 : 删除指定的信号量，如果仍然有任务在等待指定的信号量，该函数不会删除这个信号量，不过它会不断尝
//*			 : 试删除这个信号量直至没有任何任务等待该信号量时将其删除
//* 入口参数 : <hSem>[in] 指定删除的信号量句柄
//* 出口参数 : 无
//*------------------------------------------------------------------------------------------------
void OSAPISemFree(HANDLER hSem)
{
	INT8U	__ubErr;
	
	while(NULL != OSSemDel(hSem, OS_DEL_NO_PEND, &__ubErr))
		OSTimeDlyHMSM(0, 0, 0, 100);
}
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPISemFreeExt
//* 功能描述 : 删除指定的信号量，该函数相对于OSAPISemFree()函数，当出现仍然有任务在等待该信号量的情况时，所
//*			 : 有等待该信号量的任务都将进入就绪态，每个任务都得到了该信号量。
//* 入口参数 : <hSem>[in] 指定删除的信号量句柄
//* 出口参数 : 无
//*------------------------------------------------------------------------------------------------
void OSAPISemFreeExt(HANDLER hSem)
{
	INT8U	__ubErr;
	
	while(NULL != OSSemDel(hSem, OS_DEL_ALWAYS, &__ubErr))
		OSTimeDlyHMSM(0, 0, 0, 100);
}
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPIBlockNew
//* 功能描述 : 建立一个新的阻塞信号
//* 入口参数 : <ubPIP>[in] 指定在出现优先级反转时（高优先级的任务因为低优先级的任务占用同一个阻塞量而不得不
//*			 :             暂时中断正常运行以等待该阻塞量被释放从而造成事实上的优先级降低的问题），正在占用
//*			 :             该阻塞量的任务使用的较高优先级以便能够快速完成访问，释放该阻塞量 
//* 出口参数 : 建立成功返回阻塞信号句柄，否则为NULL
//*------------------------------------------------------------------------------------------------
HANDLER OSAPIBlockNew(INT8U ubPIP)
{
	INT8U		__ubErr;
	
	return (HANDLER)OSMutexCreate(ubPIP, &__ubErr);
}
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPIBlockEnter
//* 功能描述 : 进入阻塞资源，如果该资源仍然被其它任务占用，则会阻塞当前任务进程，直至指定的时间溢出或者资源
//*          : 可用
//* 入口参数 :   <hBlock>[in] 指定要使用的阻塞信号量
//*			 : <uwWaitMS>[in] 指定被阻塞的最长时间，单位为毫秒 
//* 出口参数 : - OS_NO_ERR         : 信号量可用
//*			 : - OS_TIMEOUT        : 时间溢出，信号量不可用
//*			 : - OS_ERR_EVENT_TYPE : hSem参数携带的事件类型并不是信号量而是其它类型
//*			 : - OS_ERR_PEND_ISR   : 不能在ISR中调用该函数
//*			 : - OS_ERR_PEVENT_NULL: hSem是一个空指针
//*------------------------------------------------------------------------------------------------
INT8U OSAPIBlockEnter(HANDLER hBlock, INT16U uwWaitMS)
{
	INT16U	__uwDelayTicks;
	INT8U	__ubRtnVal;
	
	if(uwWaitMS != 0)
	{
		__uwDelayTicks = (uwWaitMS * OS_TICKS_PER_SEC)/1000;
		if(__uwDelayTicks < 1)
			__uwDelayTicks = 1;
		else if(__uwDelayTicks > 65535)
			__uwDelayTicks = 65535;
		else;
	}
	else
		__uwDelayTicks = 0;
		
	OSMutexPend(hBlock, __uwDelayTicks, &__ubRtnVal);
	
	return __ubRtnVal;
}
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPIQPost
//* 功能描述 : 投递一个消息到指定的消息队列
//* 入口参数 : <hQueue>[in] 指定要投递到的消息队列
//*          :  <pvMsg>[in] 指定要投递的消息
//* 出口参数 : 与OSQPost()函数返回值除了没有OS_Q_FULL之外，其它相同
//*------------------------------------------------------------------------------------------------
INT8U OSAPIQPost(HANDLER hQueue, void *pvMsg)
{
	INT8U	__ubErr;

	while((__ubErr = OSQPost(hQueue, pvMsg)) == OS_Q_FULL)
		OSTimeDlyHMSM(0, 0, 0, 100);
		
	return __ubErr;
}
//*------------------------------------------------------------------------------------------------
//* 函数名称 : OSAPIQReceive
//* 功能描述 : 从指定的消息队列接收消息，该函数会阻塞当前的调用任务直至超时或者收到消息
//* 入口参数 :    <hQueue>[in]  指定接收消息的消息队列
//*          :     <ppMsg>[out] 结果参数，保存接收到的消息指针
//*          : <uwTimeout>[in]  指定等待接收的最长时间，为0表明一直等待直至接收到消息，单位为毫秒
//* 出口参数 : 与OSQPend()函数的结果参数err值完全相同
//*------------------------------------------------------------------------------------------------
INT8U OSAPIQReceive(HANDLER hQueue, PP ppMsg, INT16U uwTimeout)
{
	INT8U	__ubRtnVal;
	
	if(ppMsg != NULL)
		*ppMsg = OSQPend(hQueue, __MSToOSTicks(uwTimeout), &__ubRtnVal);
	else 
		OSQPend(hQueue, __MSToOSTicks(uwTimeout), &__ubRtnVal);
	
	return __ubRtnVal;
}

